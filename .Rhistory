p.values[i,1] <- eqdist.nn(z,N,k)$p.value
p.values[i,2] <- eqdist.etest(z,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=x,y=y,num.permutations=999)$p.value
}
n1<-10
n2<-100
n <- n1+n2;
N = c(n1,n2)
for(i in 1:m){
x <- matrix(rnorm(n1*p),ncol=p);
y <- cbind(rnorm(n2,0,1.5),rnorm(n2,0,2));
z <- rbind(x,y)
p.values[i,1] <- eqdist.nn(z,N,k)$p.value
p.values[i,2] <- eqdist.etest(z,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=x,y=y,num.permutations=999)$p.value
}
attach(chickwts) # chicken weights for various
x <- as.vector(weight[feed == "sunflower"])
y <- as.vector(weight[feed == "linseed"])
detach(chickwts)
z <- c(x, y)
R <- 999;
K <- 1:24;
n<-length(x);
set.seed(12345)
reps <- numeric(R);
t0 <- cor.test(x, y,method = "spearman")$statistic
for (i in 1:R) {
k <- sample(K, size = n, replace = FALSE)
x1 <- z[k]
y1 <- z[-k] #complement of x1
reps[i] <- cor.test(x1, y1,method = "spearman")$statistic
}
p<- mean(abs(c(t0, reps)) >= abs(t0))
round(c(p,cor.test(x,y)$p.value),3)
devtools::build_vignettes()
set.seed(100)
rw.Metropolis <- function(n, sigma, x0, N) {
x <- numeric(N)
x[1] <- x0
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (dt(y, n) / dt(x[i-1], n)))
x[i] <- y else {
x[i] <- x[i-1]
k <- k + 1
}
}
return(list(x=x, k=k))
}
n <- 1 #degrees of freedom for target Student t dist.
N <- 2000
sigma <-2.5
x0 <- 20
rw<- rw.Metropolis(n, sigma, x0, N)
#number of candidate points rejected
print(rw$k/N)
refline<-qt(c(0.025,0.975),df=n)
plot(rw$x,type = "l",xlab = bquote(sigma==.(round(sigma,3))),
ylab = "X",ylim = range(rw$x))
abline(h=refline)
b <- 1001 #discard the burnin sample
y <- rw$x[b:N]
a <-seq(.1, .9, .1)
Q <- qt(a, n) #theoretical quantiles
Qrw <- quantile(y, a)
print(round(cbind(Q, Qrw), 3)) #not shown
knitr::kable(round(cbind(Q, Qrw), 3))
#initialize constants and parameters
N <- 5000 #length of chain
burn <- 1000 #burn-in length
X <- matrix(0, N, 2) #the chain, a bivariate sample
a<-2;b<-3;n<-4#the paramater
X[1, ] <- c(0.2, 0.3) #initialize
for (i in 2:N) {
y <- X[i-1, 2]
X[i, 1] <- rbinom(1,n,y)
x <- X[i, 1]
X[i, 2] <- rbeta(1,x+a,n-x+b)
}
b <- burn + 1
f <- X[b:N, ]
plot(f, main="", cex=.5, xlab=bquote(x),
ylab=bquote(y), ylim=range(X[,2]))
Gelman.Rubin <- function(psi) {
# psi[i,j] is the statistic psi(X[i,1:j])
# for chain in i-th row of X
psi <- as.matrix(psi)
n <- ncol(psi)
k <- nrow(psi)
psi.means <- rowMeans(psi) #row means
B <- n * var(psi.means) #between variance est.
psi.w <- apply(psi, 1, "var") #within variances
W <- mean(psi.w) #within est.
v.hat <- W*(n-1)/n + (B/n) #upper variance est.
r.hat <- v.hat / W #G-R statistic
return(r.hat)
}
#9.1
normal.chain <- function(sigma, N, X1) {
#generates a Metropolis chain for t(1)
#with Normal(X[t], sigma^2) proposal distribution
#and starting value X1
x <- numeric(N)
x[1] <- X1
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (dt(y, n) / dt(x[i-1], n))){
x[i] <- y
}
else {
x[i] <- x[i-1]
k<- k + 1 }
}
return(x)
}
sigma <- 2.5 #parameter of proposal distribution
k <- 4 #number of chains to generate
n <- 15000 #length of chains
b <- 1000 #burn-in length
#choose overdispersed initial values
x0 <- c(-10, -5, 5, 10)
#generate the chains
X <- matrix(0, nrow=k, ncol=n)
for (i in 1:k){
X[i, ] <- normal.chain(sigma, n, x0[i])}
#trace plot
plot(1:n,X[1,],type = "l")
lines(1:n,X[2,],type = "l",col=2)
lines(1:n,X[3,],type = "l",col=3)
lines(1:n,X[4,],type = "l",col=4)
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
print(Gelman.Rubin(psi))
#plot psi for the four chains
par(mfrow=c(2,2))
for (i in 1:k)
plot(psi[i, (b+1):n], type="l",
xlab=i, ylab=bquote(psi))
par(mfrow=c(1,1)) #restore default
#plot the sequence of R-hat statistics
rhat <- rep(0, n)
for (j in (b+1):n)
rhat[j] <- Gelman.Rubin(psi[,1:j])
plot(rhat[(b+1):n], type="l", xlab="", ylab="R")
abline(h=1.1, lty=2)
devtools::build_vignettes()
set.seed(100)
rw.Metropolis <- function(n, sigma, x0, N) {
x <- numeric(N)
x[1] <- x0
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (dt(y, n) / dt(x[i-1], n)))
x[i] <- y else {
x[i] <- x[i-1]
k <- k + 1
}
}
return(list(x=x, k=k))
}
n <- 1 #degrees of freedom for target Student t dist.
N <- 2000
sigma <-2.5
x0 <- 20
rw<- rw.Metropolis(n, sigma, x0, N)
#number of candidate points rejected
print(rw$k/N)
refline<-qt(c(0.025,0.975),df=n)
plot(rw$x,type = "l",xlab = bquote(sigma==.(round(sigma,3))),
ylab = "X",ylim = range(rw$x))
abline(h=refline)
b <- 1001 #discard the burnin sample
y <- rw$x[b:N]
a <-seq(.1, .9, .1)
Q <- qt(a, n) #theoretical quantiles
Qrw <- quantile(y, a)
print(round(cbind(Q, Qrw), 3)) #not shown
knitr::kable(round(cbind(Q, Qrw), 3))
#initialize constants and parameters
N <- 5000 #length of chain
burn <- 1000 #burn-in length
X <- matrix(0, N, 2) #the chain, a bivariate sample
a<-2;b<-3;n<-4#the paramater
X[1, ] <- c(0.2, 0.3) #initialize
for (i in 2:N) {
y <- X[i-1, 2]
X[i, 1] <- rbinom(1,n,y)
x <- X[i, 1]
X[i, 2] <- rbeta(1,x+a,n-x+b)
}
b <- burn + 1
f <- X[b:N, ]
plot(f, main="", cex=.5, xlab=bquote(x),
ylab=bquote(y), ylim=range(X[,2]))
Gelman.Rubin <- function(psi) {
# psi[i,j] is the statistic psi(X[i,1:j])
# for chain in i-th row of X
psi <- as.matrix(psi)
n <- ncol(psi)
k <- nrow(psi)
psi.means <- rowMeans(psi) #row means
B <- n * var(psi.means) #between variance est.
psi.w <- apply(psi, 1, "var") #within variances
W <- mean(psi.w) #within est.
v.hat <- W*(n-1)/n + (B/n) #upper variance est.
r.hat <- v.hat / W #G-R statistic
return(r.hat)
}
#9.1
normal.chain <- function(sigma, N, X1) {
#generates a Metropolis chain for t(1)
#with Normal(X[t], sigma^2) proposal distribution
#and starting value X1
x <- numeric(N)
x[1] <- X1
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (dt(y, n) / dt(x[i-1], n))){
x[i] <- y
}
else {
x[i] <- x[i-1]
k<- k + 1 }
}
return(x)
}
sigma <- 2.5 #parameter of proposal distribution
k <- 4 #number of chains to generate
n <- 15000 #length of chains
b <- 1000 #burn-in length
#choose overdispersed initial values
x0 <- c(-10, -5, 5, 10)
#generate the chains
X <- matrix(0, nrow=k, ncol=n)
for (i in 1:k){
X[i, ] <- normal.chain(sigma, n, x0[i])}
#trace plot
plot(1:n,X[1,],type = "l")
lines(1:n,X[2,],type = "l",col=2)
lines(1:n,X[3,],type = "l",col=3)
lines(1:n,X[4,],type = "l",col=4)
psi <- t(apply(X, 1, cumsum))
for (i in 1:nrow(psi))
psi[i,] <- psi[i,] / (1:ncol(psi))
print(Gelman.Rubin(psi))
#plot psi for the four chains
par(mfrow=c(2,2))
for (i in 1:k)
plot(psi[i, (b+1):n], type="l",
xlab=i, ylab=bquote(psi))
par(mfrow=c(1,1)) #restore default
#plot the sequence of R-hat statistics
rhat <- rep(0, n)
for (j in (b+1):n)
rhat[j] <- Gelman.Rubin(psi[,1:j])
plot(rhat[(b+1):n], type="l", xlab="", ylab="R")
abline(h=1.1, lty=2)
devtools::build_vignettes()
.Last.error.trace
devtools::build_vignettes()
f<-function(k,a,d)
{
m1<-exp(-log(factorial(k))-k*log(2))
m2<-exp((2*k+2)*log(sqrt(sum(a^2)))-log(2*k+1)-log(2*k+2))
m3<-exp(lgamma((d+1)/2)+lgamma(k+3/2)-lgamma(k+d/2+1))
((-1)^k)*m1*m2*m3
}
g<-function(n){
sum<-0
for (i in 0:n) {
sum<-sum+f(i,a,d)
}
sum
}
#set d=2#
a<-c(1,2)
d<-2
result<-matrix(nrow = 2,ncol = 7)
n<-round(c(1,5,10,50,100,200,300),0)
result[1,]<-n
result[2,]<-c(g(1),g(5),g(10),g(50),g(100),g(200),g(300))
dimnames(result)[[1]]<-c("n","value")
knitr::kable(result)
g <- function(a,k) {
pt(sqrt((a^2*k)/(k+1-a^2)),k,lower.tail = FALSE)
}
Z<-matrix(0,nrow = 25,ncol=3)
j<-0
for (i in c(4:25,100,500,1000)){
h<-function(a){
g(a,i)-g(a,i-1)
}
res <- uniroot(h,lower =0.01,upper = sqrt(i)-0.01)
j<-j+1
Z[j,1]<-res$root
Z[j,2]<-res$f.root
Z[j,3]<-res$iter
}
result<-matrix(nrow = 25,ncol = 4)
result[,1]<-c(4:25,100,500,1000)
result[,2:4]<-Z
dimnames(result)[[2]]<-c("k","root","f.root","iter")
knitr::kable(result)
g <- function(a,k) {
f<-function(u){
(1+u^2/(k-1))^(-k/2)
}
c<-sqrt(((a^2)*k)/(k+1-a^2))
d<-exp(log(2)+lgamma((k+1)/2)-(1/2)*log(pi*(k))-lgamma(k/2))
it<-integrate(f,lower = 0,upper = c)
d*it$value
}
Z<-matrix(0,nrow = 25,ncol=3)
j<-0
for (i in c(4:25,100,500,1000)){
h<-function(a){
g(a,i)-g(a,i-1)
}
res <- uniroot(h,lower =0.01,upper = sqrt(i)-0.01)
j<-j+1
Z[j,1]<-res$root
Z[j,2]<-res$f.root
Z[j,3]<-res$iter
}
result<-matrix(nrow = 25,ncol = 4)
result[,1]<-c(4:25,100,500,1000)
result[,2:4]<-Z
dimnames(result)[[2]]<-c("k","root","f.root","iter")
knitr::kable(result)
#compute MLE of lambda
y<-c(0.54,0.48, 0.33,0.43,0.91,0.21,0.85,1.00,1.00,1.00)
mlogL <- function(lambda=1) {
# minus log-likelihood
return(-(length(y)*log(lambda)-lambda*sum(y)))
}
library(stats4)
fit <- mle(mlogL)
as.numeric(c(1/mean(y),fit@coef,sqrt(fit@vcov)))
library(imager)
imgjpg<-load.image("E:/研一上/统计计算/作业/11-18.jpg")
devtools::build_vignettes()
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(100)
lapply(trims, function(trim) mean(x, trim = trim))
lapply(trims, mean, x = x)
#11.1.2.3
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
#lapply()
result<-lapply(formulas, function(x) lm(x,data = mtcars))
unlist(lapply(result,function(mod) summary(mod)$r.squared))
#11.1.2.4
set.seed(123)
bootstraps <- lapply(1:10, function(i) {
rows <- sample(1:nrow(mtcars), rep = TRUE)
mtcars[rows, ]
})
result<-lapply(bootstraps, function(x) lm(mpg ~ disp,data = x))
unlist(lapply(result,function(mod) summary(mod)$r.squared))
#Use vapply() to: a) Compute the standard deviation of every column in a numeric data frame.
x<-rnorm(10,0,1)
y<-rnorm(10,0,2)
z<-rnorm(10,0,3)
d<-data.frame(x,y,z)
vapply(d, sd, FUN.VALUE = numeric(1))
# Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you’ll need to use vapply() twice.)
d <- data.frame(x = 1:10,y=21:30, z = letters[1:10])
a<-vapply(d, function(x) is.numeric(x) ,FUN.VALUE = logical(1) )
vapply(d[,a], function(x) sd(x), FUN.VALUE = numeric(1))
devtools::build_vignettes()
set.seed(1)
library(Rcpp)
library(microbenchmark)
#write Rcpp function
cppFunction(' NumericMatrix gibbsC(int N,int n,int a,int b) {
NumericMatrix X(N,2);
X(0,0)=0.2;
X(0,1)=0.3;
for(int i = 1; i < N; i++) {
double y = X(i-1, 1);
X(i, 0) = rbinom(1,n,y)[0];
double x = X(i, 0);
X(i, 1) = rbeta(1,x+a,n-x+b)[0];
}
return X;
}')
#R function
gibbsR<-function(N,n,a,b){
X <- matrix(0, N, 2)
X[1, ] <- c(0.2, 0.3) #initialize
for (i in 2:N) {
y <- X[i-1, 2]
X[i, 1] <- rbinom(1,n,y)
x <- X[i, 1]
X[i, 2] <- rbeta(1,x+a,n-x+b)
}
X
}
N<-1000
a<-2;b<-3;n<-4
gibbsr=gibbsR(N,n,a,b)
gibbsc=gibbsC(N,n,a,b)
qqplot(gibbsr[,1],gibbsc[,1])
qqplot(gibbsr[,2],gibbsc[,2])
ts <- microbenchmark(gibbsr=gibbsR(N,n,a,b),
gibbsc=gibbsC(N,n,a,b))
summary(ts)[,c(1,3,5,6)]
devtools::build_vignettes()
tls<-function(X,y,W,q) {
n<-nrow(X)
Tn<-numeric(n)
fit1<-list()
X<-as.matrix(X)
#first stage
for (i in 1:n) {
#searching for gamma
gamma<-q[i]
D1<-matrix(0,n,n)
diag(D1)<-as.numeric(q<=gamma)
D2<-diag(x=1,n,n)-D1
#instrument variable
Z<-cbind(X,W%*%X,W%*%D1%*%W%*%X,W%*%D2%*%W%*%X)
fit1[[i]]<-lm(W%*%y~Z+0)
}
Wy_hat<-matrix(0,n,n)
for (i in 1:n) {
Wy_hat[,i]<-fit1[[i]]$fitted.values
}
#second stage
fit2<-list()
estimates<-list()
sse<-numeric(n)
for (i in 1:n){
X_1<-cbind(D1%*%Wy_hat[,i],D2%*%Wy_hat[,i],X)
fit2[[i]]<-lm(y~X_1+0)
estimates[[i]]<-fit2[[i]]$coefficients
sse[i]<-t(fit2[[i]]$residuals)%*%(fit2[[i]]$residuals)
}
gammahat<-q[which(sse==min(sse))][1]
return(c(gammahat,unlist(slopecoefhat<-estimates[which(sse==min(sse))][1])))
}
sml<-function(t,n,beta1,beta2,delta,gam){
d<-5
g<-matrix(0,t,d)
W<-matrix(0,n,n)
for (i in 1:n) {
for (j in 1:n) {
if(abs(j-i)<=3)
W[i,j]<-1
}
}
W <- sweep(W, 1, apply(W, 1, function(x) sqrt(sum(x^2))), "/")
for (i in 1:t) {
X1<-rnorm(n);X2<-rnorm(n);X<-cbind(X1,X2)
q<-rnorm(n,2,1);u<-rnorm(n)
D1<-matrix(0,n,n)
diag(D1)<-as.numeric(q<=gam)
D2<-diag(x=1,n,n)-D1
Lambda<-solve(diag(x=1,n,n)-beta1*D1%*%W-beta2*D2%*%W)
y<-Lambda%*%(X%*%delta+u)
fit<-tls(X,y,W,q)
g[i,1]<-fit[1]
g[i,2:5]<-fit[2:5]
}
g<-data.frame(g)
for (i in 1:5) {
result<-lapply(g,function(x) quantile(x,probs = c(0.05,0.5,0.95),na.rm=TRUE)
)
}
result<-t(as.data.frame(result))
rownames(result)<-c("gamma","beta1","beta2","delta1","delta2")
knitr::kable(result)
}
t<-10;n<-10
gamma<-2;beta1<-0.2;beta2<-0.5;delta<-c(1,1);
sml(t,n,beta1,beta2,delta,gamma)
t<-10;n<-100
gamma<-2;beta1<-0.2;beta2<-0.5;delta<-c(1,1);
sml(t,n,beta1,beta2,delta,gamma)
t<-10;n<-c(50,100,150)
gamma<-2;beta1<-0.2;beta2<-0.5;delta<-c(1,1);
sml(t,n[1],beta1,beta2,delta,gamma)
sml(t,n[2],beta1,beta2,delta,gamma)
sml(t,n[3],beta1,beta2,delta,gamma)
t<-100;n<-c(50,100,150)
gamma<-2;beta1<-0.2;beta2<-0.5;delta<-c(1,1);
sml(t,n[1],beta1,beta2,delta,gamma)
sml(t,n[2],beta1,beta2,delta,gamma)
sml(t,n[3],beta1,beta2,delta,gamma)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
install.packages('../StatComp_1.0.tar.gz',repo=NULL)
install.packages('../StatComp21011.tar.gz',repo=NULL)
install.packages('../StatComp21011_1.0.tar.gz',repo=NULL)
devtools::build(vignettes=FALSE)
install.packages('../StatComp21011_1.0.tar.gz',repo=NULL)
